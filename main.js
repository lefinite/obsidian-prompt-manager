/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// main.ts
__export(exports, {
  PromptManagerPlugin: () => PromptManagerPlugin
});
var import_obsidian2 = __toModule(require("obsidian"));

// promptView.ts
var import_obsidian = __toModule(require("obsidian"));
var VIEW_TYPE_PROMPT = "prompt-manager-view";
var PromptView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.prompts = [];
    this.viewType = "list";
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_PROMPT;
  }
  getDisplayText() {
    return "Prompt Manager";
  }
  async onOpen() {
    this.containerEl.empty();
    this.containerEl.classList.add("prompt-manager-view");
    const topContainer = this.containerEl.createDiv("top-container");
    this.searchInput = topContainer.createEl("input", { cls: "prompt-search-input" });
    this.searchInput.type = "text";
    this.searchInput.placeholder = "Search prompts...";
    this.searchInput.addEventListener("input", () => {
      this.filterPrompts(this.searchInput.value.toLowerCase());
    });
    this.refreshButton = topContainer.createEl("button", { cls: "prompt-refresh-btn" });
    this.refreshButton.setText("\u{1F504} Refresh");
    this.refreshButton.onclick = async () => {
      await this.refresh();
      this.render();
    };
    const newButton = topContainer.createEl("button", { cls: "prompt-new-btn" });
    newButton.setText("New Prompt");
    newButton.onclick = () => this.showNewPromptModal();
    const toggleViewButton = topContainer.createEl("button", { cls: "prompt-toggle-view-btn" });
    toggleViewButton.setText(this.viewType === "board" ? "List View" : "Board View");
    toggleViewButton.onclick = () => {
      this.viewType = this.viewType === "board" ? "list" : "board";
      toggleViewButton.setText(this.viewType === "board" ? "List View" : "Board View");
      this.render();
    };
    await this.refresh();
    this.render();
  }
  render() {
    const topContainer = this.containerEl.querySelector(".top-container");
    this.containerEl.empty();
    this.containerEl.appendChild(topContainer);
    const content = this.containerEl.createDiv("prompt-content");
    if (this.viewType === "list") {
      this.renderList(content);
    } else {
      this.renderBoard(content);
    }
  }
  async refresh() {
    const promptFolderPath = this.plugin.settings.promptFolderPath;
    if (!promptFolderPath) {
      new import_obsidian.Notice("Please select a prompts folder in the plugin settings.");
      return;
    }
    const folder = this.app.vault.getAbstractFileByPath(promptFolderPath);
    if (!folder || !(folder instanceof import_obsidian.TFolder)) {
      new import_obsidian.Notice("Invalid prompts folder selected.");
      return;
    }
    const files = this.app.vault.getFiles().filter((file) => file.parent && file.parent.path === folder.path);
    const mdFiles = files.filter((file) => file.extension === "md");
    this.prompts = await Promise.all(mdFiles.map(async (file) => {
      const content = await this.app.vault.read(file);
      const { version, details, fullContent } = this.extractPromptData(content);
      return {
        name: file.basename,
        version,
        details,
        fullContent,
        file
      };
    }));
    this.prompts.sort((a, b) => {
      const versionA = parseFloat(a.version);
      const versionB = parseFloat(b.version);
      return versionB - versionA;
    });
  }
  extractPromptData(content) {
    const versionMatches = Array.from(content.matchAll(/### Version\s+(\d+(?:\.\d+)?)\n([\s\S]*?)(?=### Version|\z)/g));
    if (versionMatches.length === 0) {
      return { version: "0.0", details: content.trim(), fullContent: content };
    }
    const lastVersion = versionMatches[versionMatches.length - 1];
    const version = lastVersion[1];
    const versionContent = lastVersion[2].trim();
    const fullContent = versionMatches.map((v) => `### Version ${v[1]}
${v[2]}`).join("\n\n");
    return {
      version,
      details: versionContent,
      fullContent
    };
  }
  renderList(container) {
    const list = container.createEl("table", "prompt-list-table");
    const header = list.createEl("thead").createEl("tr");
    header.createEl("th").setText("Name");
    header.createEl("th").setText("Version");
    header.createEl("th").setText("Actions");
    const body = list.createEl("tbody");
    this.prompts.forEach((prompt) => {
      const row = body.createEl("tr");
      row.createEl("td").setText(prompt.name);
      row.createEl("td").setText(prompt.version);
      const actionsTd = row.createEl("td");
      const editBtn = actionsTd.createEl("button", { cls: "prompt-edit-btn" });
      editBtn.setText("Edit");
      editBtn.onclick = () => this.openPrompt(prompt.file);
      const copyBtn = actionsTd.createEl("button", { cls: "prompt-copy-btn" });
      copyBtn.setText("Copy");
      copyBtn.onclick = () => {
        navigator.clipboard.writeText(prompt.details).then(() => {
          new import_obsidian.Notice(`Copied prompt version ${prompt.version} content`);
        }).catch((err) => {
          console.error("Failed to copy: ", err);
          new import_obsidian.Notice("Failed to copy content");
        });
      };
    });
  }
  renderBoard(container) {
    const board = container.createDiv("prompt-board");
    this.prompts.forEach((prompt) => {
      const card = board.createDiv("prompt-card");
      const header = card.createDiv("prompt-header");
      header.createEl("h3").setText(prompt.name);
      const versionSpan = header.createEl("span", { cls: "prompt-version" });
      versionSpan.setText(`v${prompt.version}`);
      const details = card.createDiv("prompt-details");
      details.setText(prompt.details);
      const copyBtn = card.createEl("button", { cls: "prompt-copy-btn" });
      copyBtn.setText("Copy");
      copyBtn.onclick = (e) => {
        e.stopPropagation();
        navigator.clipboard.writeText(prompt.details).then(() => {
          new import_obsidian.Notice(`Copied prompt version ${prompt.version} content`);
        }).catch((err) => {
          console.error("Failed to copy: ", err);
          new import_obsidian.Notice("Failed to copy content");
        });
      };
      card.onclick = () => this.openPrompt(prompt.file);
    });
  }
  filterPrompts(searchTerm) {
    const items = this.containerEl.querySelectorAll(this.viewType === "board" ? ".prompt-card" : ".prompt-list-table tbody tr");
    items.forEach((item) => {
      var _a;
      const text = ((_a = item.textContent) == null ? void 0 : _a.toLowerCase()) || "";
      item.style.display = text.includes(searchTerm) ? "" : "none";
    });
  }
  async showNewPromptModal() {
    const modal = new NewPromptModal(this.app, async (name) => {
      if (name) {
        const promptFolderPath = this.plugin.settings.promptFolderPath;
        if (!promptFolderPath) {
          new import_obsidian.Notice("Please select a prompts folder in the plugin settings.");
          return;
        }
        const folder = this.app.vault.getAbstractFileByPath(promptFolderPath);
        if (!folder || !(folder instanceof import_obsidian.TFolder)) {
          new import_obsidian.Notice("Invalid prompts folder selected.");
          return;
        }
        const content = `### Version 1.0

New prompt content`;
        const file = await this.app.vault.create(name + ".md", content);
        await this.refresh();
        this.render();
      }
    });
    modal.open();
  }
  async openPrompt(file) {
    const leaf = this.app.workspace.getLeaf();
    if (leaf) {
      await leaf.openFile(file);
    }
  }
};
var NewPromptModal = class extends import_obsidian.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2").setText("Create New Prompt");
    const input = contentEl.createEl("input", { cls: "prompt-name-input" });
    input.type = "text";
    input.placeholder = "Enter prompt name";
    input.autofocus = true;
    const buttonContainer = contentEl.createDiv("button-container");
    const submitButton = buttonContainer.createEl("button", { cls: "prompt-submit-btn" });
    submitButton.setText("Create");
    submitButton.onclick = () => {
      this.onSubmit(input.value);
      this.close();
    };
    const cancelButton = buttonContainer.createEl("button", { cls: "prompt-cancel-btn" });
    cancelButton.setText("Cancel");
    cancelButton.onclick = () => this.close();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// main.ts
var PromptManagerPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerView("prompt-manager", (leaf) => new PromptView(leaf, this));
    this.addCommand({
      id: "show-prompt-view",
      name: "Show Prompt Manager",
      callback: () => {
        this.activateView();
      }
    });
    this.addSettingTab(new PromptManagerSettingTab(this.app, this));
  }
  async loadSettings() {
    this.settings = Object.assign({}, { promptFolderPath: "prompts" }, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType("prompt-manager")[0];
    if (!leaf) {
      const newLeaf = workspace.getRightLeaf(false);
      if (newLeaf) {
        leaf = newLeaf;
        await leaf.setViewState({ type: "prompt-manager", active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  async createPrompt(name, content = "") {
    const folderPath = (0, import_obsidian2.normalizePath)(this.settings.promptFolderPath);
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!folder) {
      await this.app.vault.createFolder(folderPath);
    }
    const filePath = (0, import_obsidian2.normalizePath)(`${folderPath}/${name}.md`);
    await this.app.vault.create(filePath, content);
  }
  async getPrompts() {
    const folderPath = (0, import_obsidian2.normalizePath)(this.settings.promptFolderPath);
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!folder) {
      return [];
    }
    return this.app.vault.getFiles().filter((file) => file.parent && file.parent.path === folder.path && file.extension === "md");
  }
};
var PromptManagerSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setName("Prompts Folder Path").setDesc("Select the folder where prompts are stored.").addText((text) => text.setValue(this.plugin.settings.promptFolderPath).onChange(async (value) => {
      this.plugin.settings.promptFolderPath = value;
      await this.plugin.saveSettings();
    }));
  }
};
